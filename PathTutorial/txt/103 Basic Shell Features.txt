3 Basic Shell Features
**********************

Bash is an acronym for 'Bourne-Again SHell'.  The Bourne shell is the
traditional Unix shell originally written by Stephen Bourne.  All of the
Bourne shell builtin commands are available in Bash, The rules for
evaluation and quoting are taken from the POSIX specification for the
'standard' Unix shell.

   This chapter briefly summarizes the shell's 'building blocks':
commands, control structures, shell functions, shell parameters, shell
expansions, redirections, which are a way to direct input and output
from and to named files, and how the shell executes commands.

3.1 Shell Syntax
================

When the shell reads input, it proceeds through a sequence of
operations.  If the input indicates the beginning of a comment, the
shell ignores the comment symbol ('#'), and the rest of that line.

   Otherwise, roughly speaking, the shell reads its input and divides
the input into words and operators, employing the quoting rules to
select which meanings to assign various words and characters.

   The shell then parses these tokens into commands and other
constructs, removes the special meaning of certain words or characters,
expands others, redirects input and output as needed, executes the
specified command, waits for the command's exit status, and makes that
exit status available for further inspection or processing.

3.1.1 Shell Operation
---------------------

The following is a brief description of the shell's operation when it
reads and executes a command.  Basically, the shell does the following:

  1. Reads its input from a file (*note Shell Scripts::), from a string
     supplied as an argument to the '-c' invocation option (*note
     Invoking Bash::), or from the user's terminal.

  2. Breaks the input into words and operators, obeying the quoting
     rules described in *note Quoting::.  These tokens are separated by
     'metacharacters'.  Alias expansion is performed by this step (*note
     Aliases::).

  3. Parses the tokens into simple and compound commands (*note Shell
     Commands::).

  4. Performs the various shell expansions (*note Shell Expansions::),
     breaking the expanded tokens into lists of filenames (*note
     Filename Expansion::) and commands and arguments.

  5. Performs any necessary redirections (*note Redirections::) and
     removes the redirection operators and their operands from the
     argument list.

  6. Executes the command (*note Executing Commands::).

  7. Optionally waits for the command to complete and collects its exit
     status (*note Exit Status::).

3.1.2 Quoting
-------------

Quoting is used to remove the special meaning of certain characters or
words to the shell.  Quoting can be used to disable special treatment
for special characters, to prevent reserved words from being recognized
as such, and to prevent parameter expansion.

   Each of the shell metacharacters (*note Definitions::) has special
meaning to the shell and must be quoted if it is to represent itself.
When the command history expansion facilities are being used (*note
History Interaction::), the HISTORY EXPANSION character, usually '!',
must be quoted to prevent history expansion.  *Note Bash History
Facilities::, for more details concerning history expansion.

   There are three quoting mechanisms: the ESCAPE CHARACTER, single
quotes, and double quotes.

3.1.2.1 Escape Character
........................

A non-quoted backslash '\' is the Bash escape character.  It preserves
the literal value of the next character that follows, with the exception
of 'newline'.  If a '\newline' pair appears, and the backslash itself is
not quoted, the '\newline' is treated as a line continuation (that is,
it is removed from the input stream and effectively ignored).

3.1.2.2 Single Quotes
.....................

Enclosing characters in single quotes (''') preserves the literal value
of each character within the quotes.  A single quote may not occur
between single quotes, even when preceded by a backslash.

3.1.2.3 Double Quotes
.....................

Enclosing characters in double quotes ('"') preserves the literal value
of all characters within the quotes, with the exception of '$', '`',
'\', and, when history expansion is enabled, '!'.  The characters '$'
and '`' retain their special meaning within double quotes (*note Shell
Expansions::).  The backslash retains its special meaning only when
followed by one of the following characters: '$', '`', '"', '\', or
'newline'.  Within double quotes, backslashes that are followed by one
of these characters are removed.  Backslashes preceding characters
without a special meaning are left unmodified.  A double quote may be
quoted within double quotes by preceding it with a backslash.  If
enabled, history expansion will be performed unless an '!' appearing in
double quotes is escaped using a backslash.  The backslash preceding the
'!' is not removed.

   The special parameters '*' and '@' have special meaning when in
double quotes (*note Shell Parameter Expansion::).

3.1.2.4 ANSI-C Quoting
......................

Words of the form '$'STRING'' are treated specially.  The word expands
to STRING, with backslash-escaped characters replaced as specified by
the ANSI C standard.  Backslash escape sequences, if present, are
decoded as follows:

'\a'
     alert (bell)
'\b'
     backspace
'\e'
'\E'
     an escape character (not ANSI C)
'\f'
     form feed
'\n'
     newline
'\r'
     carriage return
'\t'
     horizontal tab
'\v'
     vertical tab
'\\'
     backslash
'\''
     single quote
'\"'
     double quote
'\NNN'
     the eight-bit character whose value is the octal value NNN (one to
     three digits)
'\xHH'
     the eight-bit character whose value is the hexadecimal value HH
     (one or two hex digits)
'\uHHHH'
     the Unicode (ISO/IEC 10646) character whose value is the
     hexadecimal value HHHH (one to four hex digits)
'\UHHHHHHHH'
     the Unicode (ISO/IEC 10646) character whose value is the
     hexadecimal value HHHHHHHH (one to eight hex digits)
'\cX'
     a control-X character

The expanded result is single-quoted, as if the dollar sign had not been
present.

3.1.2.5 Locale-Specific Translation
...................................

A double-quoted string preceded by a dollar sign ('$') will cause the
string to be translated according to the current locale.  If the current
locale is 'C' or 'POSIX', the dollar sign is ignored.  If the string is
translated and replaced, the replacement is double-quoted.

   Some systems use the message catalog selected by the 'LC_MESSAGES'
shell variable.  Others create the name of the message catalog from the
value of the 'TEXTDOMAIN' shell variable, possibly adding a suffix of
'.mo'.  If you use the 'TEXTDOMAIN' variable, you may need to set the
'TEXTDOMAINDIR' variable to the location of the message catalog files.
Still others use both variables in this fashion:
'TEXTDOMAINDIR'/'LC_MESSAGES'/LC_MESSAGES/'TEXTDOMAIN'.mo.

3.1.3 Comments
--------------

In a non-interactive shell, or an interactive shell in which the
'interactive_comments' option to the 'shopt' builtin is enabled (*note
The Shopt Builtin::), a word beginning with '#' causes that word and all
remaining characters on that line to be ignored.  An interactive shell
without the 'interactive_comments' option enabled does not allow
comments.  The 'interactive_comments' option is on by default in
interactive shells.  *Note Interactive Shells::, for a description of
what makes a shell interactive.

3.2 Shell Commands
==================

A simple shell command such as 'echo a b c' consists of the command
itself followed by arguments, separated by spaces.

   More complex shell commands are composed of simple commands arranged
together in a variety of ways: in a pipeline in which the output of one
command becomes the input of a second, in a loop or conditional
construct, or in some other grouping.

3.2.1 Simple Commands
---------------------

A simple command is the kind of command encountered most often.  It's
just a sequence of words separated by 'blank's, terminated by one of the
shell's control operators (*note Definitions::).  The first word
generally specifies a command to be executed, with the rest of the words
being that command's arguments.

   The return status (*note Exit Status::) of a simple command is its
exit status as provided by the POSIX 1003.1 'waitpid' function, or 128+N
if the command was terminated by signal N.

3.2.2 Pipelines
---------------

A 'pipeline' is a sequence of simple commands separated by one of the
control operators '|' or '|&'.

   The format for a pipeline is
     [time [-p]] [!] COMMAND1 [ [| or |&] COMMAND2 ...]

The output of each command in the pipeline is connected via a pipe to
the input of the next command.  That is, each command reads the previous
command's output.  This connection is performed before any redirections
specified by the command.

   If '|&' is used, the standard error of COMMAND1 is connected to
COMMAND2's standard input through the pipe; it is shorthand for '2>&1
|'.  This implicit redirection of the standard error is performed after
any redirections specified by the command.

   The reserved word 'time' causes timing statistics to be printed for
the pipeline once it finishes.  The statistics currently consist of
elapsed (wall-clock) time and user and system time consumed by the
command's execution.  The '-p' option changes the output format to that
specified by POSIX.  When the shell is in POSIX mode (*note Bash POSIX
Mode::), it does not recognize 'time' as a reserved word if the next
token begins with a '-'.  The 'TIMEFORMAT' variable may be set to a
format string that specifies how the timing information should be
displayed.  *Note Bash Variables::, for a description of the available
formats.  The use of 'time' as a reserved word permits the timing of
shell builtins, shell functions, and pipelines.  An external 'time'
command cannot time these easily.

   When the shell is in POSIX mode (*note Bash POSIX Mode::), 'time' may
be followed by a newline.  In this case, the shell displays the total
user and system time consumed by the shell and its children.  The
'TIMEFORMAT' variable may be used to specify the format of the time
information.

   If the pipeline is not executed asynchronously (*note Lists::), the
shell waits for all commands in the pipeline to complete.

   Each command in a pipeline is executed in its own subshell (*note
Command Execution Environment::).  The exit status of a pipeline is the
exit status of the last command in the pipeline, unless the 'pipefail'
option is enabled (*note The Set Builtin::).  If 'pipefail' is enabled,
the pipeline's return status is the value of the last (rightmost)
command to exit with a non-zero status, or zero if all commands exit
successfully.  If the reserved word '!' precedes the pipeline, the exit
status is the logical negation of the exit status as described above.
The shell waits for all commands in the pipeline to terminate before
returning a value.

3.2.3 Lists of Commands
-----------------------

A 'list' is a sequence of one or more pipelines separated by one of the
operators ';', '&', '&&', or '||', and optionally terminated by one of
';', '&', or a 'newline'.

   Of these list operators, '&&' and '||' have equal precedence,
followed by ';' and '&', which have equal precedence.

   A sequence of one or more newlines may appear in a 'list' to delimit
commands, equivalent to a semicolon.

   If a command is terminated by the control operator '&', the shell
executes the command asynchronously in a subshell.  This is known as
executing the command in the BACKGROUND.  The shell does not wait for
the command to finish, and the return status is 0 (true).  When job
control is not active (*note Job Control::), the standard input for
asynchronous commands, in the absence of any explicit redirections, is
redirected from '/dev/null'.

   Commands separated by a ';' are executed sequentially; the shell
waits for each command to terminate in turn.  The return status is the
exit status of the last command executed.

   AND and OR lists are sequences of one or more pipelines separated by
the control operators '&&' and '||', respectively.  AND and OR lists are
executed with left associativity.

   An AND list has the form
     COMMAND1 && COMMAND2

COMMAND2 is executed if, and only if, COMMAND1 returns an exit status of
zero.

   An OR list has the form
     COMMAND1 || COMMAND2

COMMAND2 is executed if, and only if, COMMAND1 returns a non-zero exit
status.

   The return status of AND and OR lists is the exit status of the last
command executed in the list.

3.2.4 Compound Commands
-----------------------

Compound commands are the shell programming constructs.  Each construct
begins with a reserved word or control operator and is terminated by a
corresponding reserved word or operator.  Any redirections (*note
Redirections::) associated with a compound command apply to all commands
within that compound command unless explicitly overridden.

   Bash provides looping constructs, conditional commands, and
mechanisms to group commands and execute them as a unit.

3.2.4.1 Looping Constructs
..........................

Bash supports the following looping constructs.

   Note that wherever a ';' appears in the description of a command's
syntax, it may be replaced with one or more newlines.

'until'
     The syntax of the 'until' command is:
          until TEST-COMMANDS; do CONSEQUENT-COMMANDS; done
     Execute CONSEQUENT-COMMANDS as long as TEST-COMMANDS has an exit
     status which is not zero.  The return status is the exit status of
     the last command executed in CONSEQUENT-COMMANDS, or zero if none
     was executed.

'while'
     The syntax of the 'while' command is:
          while TEST-COMMANDS; do CONSEQUENT-COMMANDS; done

     Execute CONSEQUENT-COMMANDS as long as TEST-COMMANDS has an exit
     status of zero.  The return status is the exit status of the last
     command executed in CONSEQUENT-COMMANDS, or zero if none was
     executed.

'for'
     The syntax of the 'for' command is:

          for NAME [ [in [WORDS ...] ] ; ] do COMMANDS; done
     Expand WORDS, and execute COMMANDS once for each member in the
     resultant list, with NAME bound to the current member.  If 'in
     WORDS' is not present, the 'for' command executes the COMMANDS once
     for each positional parameter that is set, as if 'in "$@"' had been
     specified (*note Special Parameters::).  The return status is the
     exit status of the last command that executes.  If there are no
     items in the expansion of WORDS, no commands are executed, and the
     return status is zero.

     An alternate form of the 'for' command is also supported:

          for (( EXPR1 ; EXPR2 ; EXPR3 )) ; do COMMANDS ; done
     First, the arithmetic expression EXPR1 is evaluated according to
     the rules described below (*note Shell Arithmetic::).  The
     arithmetic expression EXPR2 is then evaluated repeatedly until it
     evaluates to zero.  Each time EXPR2 evaluates to a non-zero value,
     COMMANDS are executed and the arithmetic expression EXPR3 is
     evaluated.  If any expression is omitted, it behaves as if it
     evaluates to 1.  The return value is the exit status of the last
     command in COMMANDS that is executed, or false if any of the
     expressions is invalid.

   The 'break' and 'continue' builtins (*note Bourne Shell Builtins::)
may be used to control loop execution.

3.2.4.2 Conditional Constructs
..............................

'if'
     The syntax of the 'if' command is:

          if TEST-COMMANDS; then
            CONSEQUENT-COMMANDS;
          [elif MORE-TEST-COMMANDS; then
            MORE-CONSEQUENTS;]
          [else ALTERNATE-CONSEQUENTS;]
          fi

     The TEST-COMMANDS list is executed, and if its return status is
     zero, the CONSEQUENT-COMMANDS list is executed.  If TEST-COMMANDS
     returns a non-zero status, each 'elif' list is executed in turn,
     and if its exit status is zero, the corresponding MORE-CONSEQUENTS
     is executed and the command completes.  If 'else
     ALTERNATE-CONSEQUENTS' is present, and the final command in the
     final 'if' or 'elif' clause has a non-zero exit status, then
     ALTERNATE-CONSEQUENTS is executed.  The return status is the exit
     status of the last command executed, or zero if no condition tested
     true.

'case'
     The syntax of the 'case' command is:

          case WORD in [ [(] PATTERN [| PATTERN]...) COMMAND-LIST ;;]... esac

     'case' will selectively execute the COMMAND-LIST corresponding to
     the first PATTERN that matches WORD.  If the shell option
     'nocasematch' (see the description of 'shopt' in *note The Shopt
     Builtin::) is enabled, the match is performed without regard to the
     case of alphabetic characters.  The '|' is used to separate
     multiple patterns, and the ')' operator terminates a pattern list.
     A list of patterns and an associated command-list is known as a
     CLAUSE.

     Each clause must be terminated with ';;', ';&', or ';;&'.  The WORD
     undergoes tilde expansion, parameter expansion, command
     substitution, arithmetic expansion, and quote removal before
     matching is attempted.  Each PATTERN undergoes tilde expansion,
     parameter expansion, command substitution, and arithmetic
     expansion.

     There may be an arbitrary number of 'case' clauses, each terminated
     by a ';;', ';&', or ';;&'.  The first pattern that matches
     determines the command-list that is executed.

     Here is an example using 'case' in a script that could be used to
     describe one interesting feature of an animal:


[demo]

          echo -n "Enter the name of an animal: "
          read ANIMAL
          echo -n "The $ANIMAL has "
          case $ANIMAL in
            horse | dog | cat) echo -n "four";;
            man | kangaroo ) echo -n "two";;
            *) echo -n "an unknown number of";;
          esac
          echo " legs."


[/demo]

     If the ';;' operator is used, no subsequent matches are attempted
     after the first pattern match.  Using ';&' in place of ';;' causes
     execution to continue with the COMMAND-LIST associated with the
     next clause, if any.  Using ';;&' in place of ';;' causes the shell
     to test the patterns in the next clause, if any, and execute any
     associated COMMAND-LIST on a successful match.

     The return status is zero if no PATTERN is matched.  Otherwise, the
     return status is the exit status of the COMMAND-LIST executed.

'select'

     The 'select' construct allows the easy generation of menus.  It has
     almost the same syntax as the 'for' command:

          select NAME [in WORDS ...]; do COMMANDS; done

     The list of words following 'in' is expanded, generating a list of
     items.  The set of expanded words is printed on the standard error
     output stream, each preceded by a number.  If the 'in WORDS' is
     omitted, the positional parameters are printed, as if 'in "$@"' had
     been specified.  The 'PS3' prompt is then displayed and a line is
     read from the standard input.  If the line consists of a number
     corresponding to one of the displayed words, then the value of NAME
     is set to that word.  If the line is empty, the words and prompt
     are displayed again.  If 'EOF' is read, the 'select' command
     completes.  Any other value read causes NAME to be set to null.
     The line read is saved in the variable 'REPLY'.

     The COMMANDS are executed after each selection until a 'break'
     command is executed, at which point the 'select' command completes.

     Here is an example that allows the user to pick a filename from the
     current directory, and displays the name and index of the file
     selected.

          select fname in *;
          do
          	echo you picked $fname \($REPLY\)
          	break;
          done

'((...))'
          (( EXPRESSION ))

     The arithmetic EXPRESSION is evaluated according to the rules
     described below (*note Shell Arithmetic::).  If the value of the
     expression is non-zero, the return status is 0; otherwise the
     return status is 1.  This is exactly equivalent to
          let "EXPRESSION"
     *Note Bash Builtins::, for a full description of the 'let' builtin.

'[[...]]'
          [[ EXPRESSION ]]

     Return a status of 0 or 1 depending on the evaluation of the
     conditional expression EXPRESSION.  Expressions are composed of the
     primaries described below in *note Bash Conditional Expressions::.
     Word splitting and filename expansion are not performed on the
     words between the '[[' and ']]'; tilde expansion, parameter and
     variable expansion, arithmetic expansion, command substitution,
     process substitution, and quote removal are performed.  Conditional
     operators such as '-f' must be unquoted to be recognized as
     primaries.

     When used with '[[', the '<' and '>' operators sort
     lexicographically using the current locale.

     When the '==' and '!=' operators are used, the string to the right
     of the operator is considered a pattern and matched according to
     the rules described below in *note Pattern Matching::.  If the
     shell option 'nocasematch' (see the description of 'shopt' in *note
     The Shopt Builtin::) is enabled, the match is performed without
     regard to the case of alphabetic characters.  The return value is 0
     if the string matches ('==') or does not match ('!=')the pattern,
     and 1 otherwise.  Any part of the pattern may be quoted to force it
     to be matched as a string.

     An additional binary operator, '=~', is available, with the same
     precedence as '==' and '!='.  When it is used, the string to the
     right of the operator is considered an extended regular expression
     and matched accordingly (as in regex3)).  The return value is 0 if
     the string matches the pattern, and 1 otherwise.  If the regular
     expression is syntactically incorrect, the conditional expression's
     return value is 2.  If the shell option 'nocasematch' (see the
     description of 'shopt' in *note The Shopt Builtin::) is enabled,
     the match is performed without regard to the case of alphabetic
     characters.  Any part of the pattern may be quoted to force it to
     be matched as a string.  Substrings matched by parenthesized
     subexpressions within the regular expression are saved in the array
     variable 'BASH_REMATCH'.  The element of 'BASH_REMATCH' with index
     0 is the portion of the string matching the entire regular
     expression.  The element of 'BASH_REMATCH' with index N is the
     portion of the string matching the Nth parenthesized subexpression.

     Expressions may be combined using the following operators, listed
     in decreasing order of precedence:

     '( EXPRESSION )'
          Returns the value of EXPRESSION.  This may be used to override
          the normal precedence of operators.

     '! EXPRESSION'
          True if EXPRESSION is false.

     'EXPRESSION1 && EXPRESSION2'
          True if both EXPRESSION1 and EXPRESSION2 are true.

     'EXPRESSION1 || EXPRESSION2'
          True if either EXPRESSION1 or EXPRESSION2 is true.
     The '&&' and '||' operators do not evaluate EXPRESSION2 if the
     value of EXPRESSION1 is sufficient to determine the return value of
     the entire conditional expression.

3.2.4.3 Grouping Commands
.........................

Bash provides two ways to group a list of commands to be executed as a
unit.  When commands are grouped, redirections may be applied to the
entire command list.  For example, the output of all the commands in the
list may be redirected to a single stream.

'()'
          ( LIST )

     Placing a list of commands between parentheses causes a subshell
     environment to be created (*note Command Execution Environment::),
     and each of the commands in LIST to be executed in that subshell.
     Since the LIST is executed in a subshell, variable assignments do
     not remain in effect after the subshell completes.

'{}'
          { LIST; }

     Placing a list of commands between curly braces causes the list to
     be executed in the current shell context.  No subshell is created.
     The semicolon (or newline) following LIST is required.

   In addition to the creation of a subshell, there is a subtle
difference between these two constructs due to historical reasons.  The
braces are 'reserved words', so they must be separated from the LIST by
'blank's or other shell metacharacters.  The parentheses are
'operators', and are recognized as separate tokens by the shell even if
they are not separated from the LIST by whitespace.

   The exit status of both of these constructs is the exit status of
LIST.

3.2.5 Coprocesses
-----------------

A 'coprocess' is a shell command preceded by the 'coproc' reserved word.
A coprocess is executed asynchronously in a subshell, as if the command
had been terminated with the '&' control operator, with a two-way pipe
established between the executing shell and the coprocess.

   The format for a coprocess is:
     coproc [NAME] COMMAND [REDIRECTIONS]

This creates a coprocess named NAME.  If NAME is not supplied, the
default name is COPROC.  NAME must not be supplied if COMMAND is a
simple command (*note Simple Commands::); otherwise, it is interpreted
as the first word of the simple command.

   When the coproc is executed, the shell creates an array variable
(*note Arrays::) named NAME in the context of the executing shell.  The
standard output of COMMAND is connected via a pipe to a file descriptor
in the executing shell, and that file descriptor is assigned to NAME[0].
The standard input of COMMAND is connected via a pipe to a file
descriptor in the executing shell, and that file descriptor is assigned
to NAME[1].  This pipe is established before any redirections specified
by the command (*note Redirections::).  The file descriptors can be
utilized as arguments to shell commands and redirections using standard
word expansions.

   The process ID of the shell spawned to execute the coprocess is
available as the value of the variable NAME_PID. The 'wait' builtin
command may be used to wait for the coprocess to terminate.

   The return status of a coprocess is the exit status of COMMAND.

3.2.6 GNU Parallel
------------------

GNU Parallel, as its name suggests, can be used to build and run
commands in parallel.  You may run the same command with different
arguments, whether they are filenames, usernames, hostnames, or lines
read from files.

   For a complete description, refer to the GNU Parallel documentation.
A few examples should provide a brief introduction to its use.

   For example, it is easy to prefix each line in a text file with a
specified string:
     cat file | parallel -k echo prefix_string
The '-k' option is required to preserve the lines' order.

   Similarly, you can append a specified string to each line in a text
file:
     cat file | parallel -k echo {} append_string

   You can use Parallel to move files from the current directory when
the number of files is too large to process with one 'mv' invocation:
     ls | parallel mv {} destdir

   As you can see, the {} is replaced with each line read from standard
input.  This will run as many 'mv' commands as there are files in the
current directory.  You can emulate a parallel 'xargs' by adding the
'-X' option:
     ls | parallel -X mv {} destdir

   GNU Parallel can replace certain common idioms that operate on lines
read from a file (in this case, filenames):
     	for x in $(cat list); do
     		do-something1 $x config-$x
     		do-something2 < $x
     	done | process-output

with a more compact syntax reminiscent of lambdas:
     cat list | parallel "do-something1 {} config-{} ; do-something2 < {}" | process-output

   Parallel provides a built-in mechanism to remove filename extensions,
which lends itself to batch file transformations or renaming:
     ls *.gz | parallel -j+0 "zcat {} | bzip2 >{.}.bz2 && rm {}"
This will recompress all files in the current directory with names
ending in .gz using bzip2, running one job per CPU (-j+0) in parallel.

   If a command generates output, you may want to preserve the input
order in the output.  For instance, the following command
     { echo foss.org.my ; echo debian.org; echo freenetproject.org; } | parallel traceroute
will display as output the traceroute invocation that finishes first.
Using the '-k' option, as we saw above
     { echo foss.org.my ; echo debian.org; echo freenetproject.org; } | parallel -k traceroute
will ensure that the output of 'traceroute foss.org.my' is displayed
first.

3.3 Shell Functions
===================

Shell functions are a way to group commands for later execution using a
single name for the group.  They are executed just like a "regular"
command.  When the name of a shell function is used as a simple command
name, the list of commands associated with that function name is
executed.  Shell functions are executed in the current shell context; no
new process is created to interpret them.

   Functions are declared using this syntax:
     NAME () COMPOUND-COMMAND [ REDIRECTIONS ]
     or

     function NAME [()] COMPOUND-COMMAND [ REDIRECTIONS ]

   This defines a shell function named NAME.  The reserved word
'function' is optional.  If the 'function' reserved word is supplied,
the parentheses are optional.  The BODY of the function is the compound
command COMPOUND-COMMAND (*note Compound Commands::).  That command is
usually a LIST enclosed between { and }, but may be any compound command
listed above.  COMPOUND-COMMAND is executed whenever NAME is specified
as the name of a command.  Any redirections (*note Redirections::)
associated with the shell function are performed when the function is
executed.

   A function definition may be deleted using the '-f' option to the
'unset' builtin (*note Bourne Shell Builtins::).

   The exit status of a function definition is zero unless a syntax
error occurs or a readonly function with the same name already exists.
When executed, the exit status of a function is the exit status of the
last command executed in the body.

   Note that for historical reasons, in the most common usage the curly
braces that surround the body of the function must be separated from the
body by 'blank's or newlines.  This is because the braces are reserved
words and are only recognized as such when they are separated from the
command list by whitespace or another shell metacharacter.  Also, when
using the braces, the LIST must be terminated by a semicolon, a '&', or
a newline.

   When a function is executed, the arguments to the function become the
positional parameters during its execution (*note Positional
Parameters::).  The special parameter '#' that expands to the number of
positional parameters is updated to reflect the change.  Special
parameter '0' is unchanged.  The first element of the 'FUNCNAME'
variable is set to the name of the function while the function is
executing.

   All other aspects of the shell execution environment are identical
between a function and its caller with these exceptions: the 'DEBUG' and
'RETURN' traps are not inherited unless the function has been given the
'trace' attribute using the 'declare' builtin or the '-o functrace'
option has been enabled with the 'set' builtin, (in which case all
functions inherit the 'DEBUG' and 'RETURN' traps), and the 'ERR' trap is
not inherited unless the '-o errtrace' shell option has been enabled.
*Note Bourne Shell Builtins::, for the description of the 'trap'
builtin.

   The 'FUNCNEST' variable, if set to a numeric value greater than 0,
defines a maximum function nesting level.  Function invocations that
exceed the limit cause the entire command to abort.

   If the builtin command 'return' is executed in a function, the
function completes and execution resumes with the next command after the
function call.  Any command associated with the 'RETURN' trap is
executed before execution resumes.  When a function completes, the
values of the positional parameters and the special parameter '#' are
restored to the values they had prior to the function's execution.  If a
numeric argument is given to 'return', that is the function's return
status; otherwise the function's return status is the exit status of the
last command executed before the 'return'.

   Variables local to the function may be declared with the 'local'
builtin.  These variables are visible only to the function and the
commands it invokes.

   Function names and definitions may be listed with the '-f' option to
the 'declare' or 'typeset' builtin commands (*note Bash Builtins::).
The '-F' option to 'declare' or 'typeset' will list the function names
only (and optionally the source file and line number, if the 'extdebug'
shell option is enabled).  Functions may be exported so that subshells
automatically have them defined with the '-f' option to the 'export'
builtin (*note Bourne Shell Builtins::).  Note that shell functions and
variables with the same name may result in multiple identically-named
entries in the environment passed to the shell's children.  Care should
be taken in cases where this may cause a problem.

   Functions may be recursive.  The 'FUNCNEST' variable may be used to
limit the depth of the function call stack and restrict the number of
function invocations.  By default, no limit is placed on the number of
recursive calls.

3.4 Shell Parameters
====================

A PARAMETER is an entity that stores values.  It can be a 'name', a
number, or one of the special characters listed below.  A VARIABLE is a
parameter denoted by a 'name'.  A variable has a VALUE and zero or more
ATTRIBUTES.  Attributes are assigned using the 'declare' builtin command
(see the description of the 'declare' builtin in *note Bash Builtins::).

   A parameter is set if it has been assigned a value.  The null string
is a valid value.  Once a variable is set, it may be unset only by using
the 'unset' builtin command.

   A variable may be assigned to by a statement of the form
     NAME=[VALUE]
If VALUE is not given, the variable is assigned the null string.  All
VALUEs undergo tilde expansion, parameter and variable expansion,
command substitution, arithmetic expansion, and quote removal (detailed
below).  If the variable has its 'integer' attribute set, then VALUE is
evaluated as an arithmetic expression even if the '$((...))' expansion
is not used (*note Arithmetic Expansion::).  Word splitting is not
performed, with the exception of '"$@"' as explained below.  Filename
expansion is not performed.  Assignment statements may also appear as
arguments to the 'alias', 'declare', 'typeset', 'export', 'readonly',
and 'local' builtin commands.

   In the context where an assignment statement is assigning a value to
a shell variable or array index (*note Arrays::), the '+=' operator can
be used to append to or add to the variable's previous value.  When '+='
is applied to a variable for which the INTEGER attribute has been set,
VALUE is evaluated as an arithmetic expression and added to the
variable's current value, which is also evaluated.  When '+=' is applied
to an array variable using compound assignment (*note Arrays::), the
variable's value is not unset (as it is when using '='), and new values
are appended to the array beginning at one greater than the array's
maximum index (for indexed arrays), or added as additional key-value
pairs in an associative array.  When applied to a string-valued
variable, VALUE is expanded and appended to the variable's value.

3.4.1 Positional Parameters
---------------------------

A POSITIONAL PARAMETER is a parameter denoted by one or more digits,
other than the single digit '0'.  Positional parameters are assigned
from the shell's arguments when it is invoked, and may be reassigned
using the 'set' builtin command.  Positional parameter 'N' may be
referenced as '${N}', or as '$N' when 'N' consists of a single digit.
Positional parameters may not be assigned to with assignment statements.
The 'set' and 'shift' builtins are used to set and unset them (*note
Shell Builtin Commands::).  The positional parameters are temporarily
replaced when a shell function is executed (*note Shell Functions::).

   When a positional parameter consisting of more than a single digit is
expanded, it must be enclosed in braces.

3.4.2 Special Parameters
------------------------

The shell treats several parameters specially.  These parameters may
only be referenced; assignment to them is not allowed.

'*'
     Expands to the positional parameters, starting from one.  When the
     expansion occurs within double quotes, it expands to a single word
     with the value of each parameter separated by the first character
     of the 'IFS' special variable.  That is, '"$*"' is equivalent to
     '"$1C$2C..."', where C is the first character of the value of the
     'IFS' variable.  If 'IFS' is unset, the parameters are separated by
     spaces.  If 'IFS' is null, the parameters are joined without
     intervening separators.

'@'
     Expands to the positional parameters, starting from one.  When the
     expansion occurs within double quotes, each parameter expands to a
     separate word.  That is, '"$@"' is equivalent to '"$1" "$2" ...'.
     If the double-quoted expansion occurs within a word, the expansion
     of the first parameter is joined with the beginning part of the
     original word, and the expansion of the last parameter is joined
     with the last part of the original word.  When there are no
     positional parameters, '"$@"' and '$@' expand to nothing (i.e.,
     they are removed).

'#'
     Expands to the number of positional parameters in decimal.

'?'
     Expands to the exit status of the most recently executed foreground
     pipeline.

'-'
     (A hyphen.)  Expands to the current option flags as specified upon
     invocation, by the 'set' builtin command, or those set by the shell
     itself (such as the '-i' option).

'$'
     Expands to the process ID of the shell.  In a '()' subshell, it
     expands to the process ID of the invoking shell, not the subshell.

'!'
     Expands to the process ID of the most recently executed background
     (asynchronous) command.

'0'
     Expands to the name of the shell or shell script.  This is set at
     shell initialization.  If Bash is invoked with a file of commands
     (*note Shell Scripts::), '$0' is set to the name of that file.  If
     Bash is started with the '-c' option (*note Invoking Bash::), then
     '$0' is set to the first argument after the string to be executed,
     if one is present.  Otherwise, it is set to the filename used to
     invoke Bash, as given by argument zero.

'_'
     (An underscore.)  At shell startup, set to the absolute pathname
     used to invoke the shell or shell script being executed as passed
     in the environment or argument list.  Subsequently, expands to the
     last argument to the previous command, after expansion.  Also set
     to the full pathname used to invoke each command executed and
     placed in the environment exported to that command.  When checking
     mail, this parameter holds the name of the mail file.

3.5 Shell Expansions
====================

Expansion is performed on the command line after it has been split into
'token's.  There are seven kinds of expansion performed:
   * brace expansion
   * tilde expansion
   * parameter and variable expansion
   * command substitution
   * arithmetic expansion
   * word splitting
   * filename expansion

   The order of expansions is: brace expansion, tilde expansion,
parameter, variable, and arithmetic expansion and command substitution
(done in a left-to-right fashion), word splitting, and filename
expansion.

   On systems that can support it, there is an additional expansion
available: PROCESS SUBSTITUTION.  This is performed at the same time as
parameter, variable, and arithmetic expansion and command substitution.

   Only brace expansion, word splitting, and filename expansion can
change the number of words of the expansion; other expansions expand a
single word to a single word.  The only exceptions to this are the
expansions of '"$@"' (*note Special Parameters::) and '"${NAME[@]}"'
(*note Arrays::).

   After all expansions, 'quote removal' (*note Quote Removal::) is
performed.

3.5.1 Brace Expansion
---------------------

Brace expansion is a mechanism by which arbitrary strings may be
generated.  This mechanism is similar to FILENAME EXPANSION (*note
Filename Expansion::), but the file names generated need not exist.
Patterns to be brace expanded take the form of an optional PREAMBLE,
followed by either a series of comma-separated strings or a seqeunce
expression between a pair of braces, followed by an optional POSTSCRIPT.
The preamble is prefixed to each string contained within the braces, and
the postscript is then appended to each resulting string, expanding left
to right.

   Brace expansions may be nested.  The results of each expanded string
are not sorted; left to right order is preserved.  For example,
     bash$ echo a{d,c,b}e
     ade ace abe

   A sequence expression takes the form '{X..Y[..INCR]}', where X and Y
are either integers or single characters, and INCR, an optional
increment, is an integer.  When integers are supplied, the expression
expands to each number between X and Y, inclusive.  Supplied integers
may be prefixed with '0' to force each term to have the same width.
When either X or Y begins with a zero, the shell attempts to force all
generated terms to contain the same number of digits, zero-padding where
necessary.  When characters are supplied, the expression expands to each
character lexicographically between X and Y, inclusive.  Note that both
X and Y must be of the same type.  When the increment is supplied, it is
used as the difference between each term.  The default increment is 1 or
-1 as appropriate.

   Brace expansion is performed before any other expansions, and any
characters special to other expansions are preserved in the result.  It
is strictly textual.  Bash does not apply any syntactic interpretation
to the context of the expansion or the text between the braces.  To
avoid conflicts with parameter expansion, the string '${' is not
considered eligible for brace expansion.

   A correctly-formed brace expansion must contain unquoted opening and
closing braces, and at least one unquoted comma or a valid sequence
expression.  Any incorrectly formed brace expansion is left unchanged.

   A { or ',' may be quoted with a backslash to prevent its being
considered part of a brace expression.  To avoid conflicts with
parameter expansion, the string '${' is not considered eligible for
brace expansion.

   This construct is typically used as shorthand when the common prefix
of the strings to be generated is longer than in the above example:
     mkdir /usr/local/src/bash/{old,new,dist,bugs}
   or
     chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}

3.5.2 Tilde Expansion
---------------------

If a word begins with an unquoted tilde character ('~'), all of the
characters up to the first unquoted slash (or all characters, if there
is no unquoted slash) are considered a TILDE-PREFIX.  If none of the
characters in the tilde-prefix are quoted, the characters in the
tilde-prefix following the tilde are treated as a possible LOGIN NAME.
If this login name is the null string, the tilde is replaced with the
value of the 'HOME' shell variable.  If 'HOME' is unset, the home
directory of the user executing the shell is substituted instead.
Otherwise, the tilde-prefix is replaced with the home directory
associated with the specified login name.

   If the tilde-prefix is '~+', the value of the shell variable 'PWD'
replaces the tilde-prefix.  If the tilde-prefix is '~-', the value of
the shell variable 'OLDPWD', if it is set, is substituted.

   If the characters following the tilde in the tilde-prefix consist of
a number N, optionally prefixed by a '+' or a '-', the tilde-prefix is
replaced with the corresponding element from the directory stack, as it
would be displayed by the 'dirs' builtin invoked with the characters
following tilde in the tilde-prefix as an argument (*note The Directory
Stack::).  If the tilde-prefix, sans the tilde, consists of a number
without a leading '+' or '-', '+' is assumed.

   If the login name is invalid, or the tilde expansion fails, the word
is left unchanged.

   Each variable assignment is checked for unquoted tilde-prefixes
immediately following a ':' or the first '='.  In these cases, tilde
expansion is also performed.  Consequently, one may use file names with
tildes in assignments to 'PATH', 'MAILPATH', and 'CDPATH', and the shell
assigns the expanded value.

   The following table shows how Bash treats unquoted tilde-prefixes:

'~'
     The value of '$HOME'
'~/foo'
     '$HOME/foo'

'~fred/foo'
     The subdirectory 'foo' of the home directory of the user 'fred'

'~+/foo'
     '$PWD/foo'

'~-/foo'
     '${OLDPWD-'~-'}/foo'

'~N'
     The string that would be displayed by 'dirs +N'

'~+N'
     The string that would be displayed by 'dirs +N'

'~-N'
     The string that would be displayed by 'dirs -N'

3.5.3 Shell Parameter Expansion
-------------------------------

The '$' character introduces parameter expansion, command substitution,
or arithmetic expansion.  The parameter name or symbol to be expanded
may be enclosed in braces, which are optional but serve to protect the
variable to be expanded from characters immediately following it which
could be interpreted as part of the name.

   When braces are used, the matching ending brace is the first '}' not
escaped by a backslash or within a quoted string, and not within an
embedded arithmetic expansion, command substitution, or parameter
expansion.

   The basic form of parameter expansion is ${PARAMETER}.  The value of
PARAMETER is substituted.  The braces are required when PARAMETER is a
positional parameter with more than one digit, or when PARAMETER is
followed by a character that is not to be interpreted as part of its
name.

   If the first character of PARAMETER is an exclamation point (!), a
level of variable indirection is introduced.  Bash uses the value of the
variable formed from the rest of PARAMETER as the name of the variable;
this variable is then expanded and that value is used in the rest of the
substitution, rather than the value of PARAMETER itself.  This is known
as 'indirect expansion'.  The exceptions to this are the expansions of
${!PREFIX
} and ${!NAME[@]} described below.  The exclamation point must
immediately follow the left brace in order to introduce indirection.

   In each of the cases below, WORD is subject to tilde expansion,
parameter expansion, command substitution, and arithmetic expansion.

   When not performing substring expansion, using the form described
below, Bash tests for a parameter that is unset or null.  Omitting the
colon results in a test only for a parameter that is unset.  Put another
way, if the colon is included, the operator tests for both PARAMETER's
existence and that its value is not null; if the colon is omitted, the
operator tests only for existence.

'${PARAMETER:-WORD}'
     If PARAMETER is unset or null, the expansion of WORD is
     substituted.  Otherwise, the value of PARAMETER is substituted.

'${PARAMETER:=WORD}'
     If PARAMETER is unset or null, the expansion of WORD is assigned to
     PARAMETER.  The value of PARAMETER is then substituted.  Positional
     parameters and special parameters may not be assigned to in this
     way.

'${PARAMETER:?WORD}'
     If PARAMETER is null or unset, the expansion of WORD (or a message
     to that effect if WORD is not present) is written to the standard
     error and the shell, if it is not interactive, exits.  Otherwise,
     the value of PARAMETER is substituted.

'${PARAMETER:+WORD}'
     If PARAMETER is null or unset, nothing is substituted, otherwise
     the expansion of WORD is substituted.

'${PARAMETER:OFFSET}'
'${PARAMETER:OFFSET:LENGTH}'
     Expands to up to LENGTH characters of PARAMETER starting at the
     character specified by OFFSET.  If LENGTH is omitted, expands to
     the substring of PARAMETER starting at the character specified by
     OFFSET.  LENGTH and OFFSET are arithmetic expressions (*note Shell
     Arithmetic::).  This is referred to as Substring Expansion.

     If OFFSET evaluates to a number less than zero, the value is used
     as an offset from the end of the value of PARAMETER.  If LENGTH
     evaluates to a number less than zero, and PARAMETER is not '@' and
     not an indexed or associative array, it is interpreted as an offset
     from the end of the value of PARAMETER rather than a number of
     characters, and the expansion is the characters between the two
     offsets.  If PARAMETER is '@', the result is LENGTH positional
     parameters beginning at OFFSET.  If PARAMETER is an indexed array
     name subscripted by '@' or '*', the result is the LENGTH members of
     the array beginning with '${PARAMETER[OFFSET]}'.  A negative OFFSET
     is taken relative to one greater than the maximum index of the
     specified array.  Substring expansion applied to an associative
     array produces undefined results.

     Note that a negative offset must be separated from the colon by at
     least one space to avoid being confused with the ':-' expansion.
     Substring indexing is zero-based unless the positional parameters
     are used, in which case the indexing starts at 1 by default.  If
     OFFSET is 0, and the positional parameters are used, '$@' is
     prefixed to the list.

'${!PREFIX*}'
'${!PREFIX@}'
     Expands to the names of variables whose names begin with PREFIX,
     separated by the first character of the 'IFS' special variable.
     When '@' is used and the expansion appears within double quotes,
     each variable name expands to a separate word.

'${!NAME[@]}'
'${!NAME[*]}'
     If NAME is an array variable, expands to the list of array indices
     (keys) assigned in NAME.  If NAME is not an array, expands to 0 if
     NAME is set and null otherwise.  When '@' is used and the expansion
     appears within double quotes, each key expands to a separate word.

'${#PARAMETER}'
     The length in characters of the expanded value of PARAMETER is
     substituted.  If PARAMETER is '*' or '@', the value substituted is
     the number of positional parameters.  If PARAMETER is an array name
     subscripted by '*' or '@', the value substituted is the number of
     elements in the array.

'${PARAMETER#WORD}'
'${PARAMETER##WORD}'
     The WORD is expanded to produce a pattern just as in filename
     expansion (*note Filename Expansion::).  If the pattern matches the
     beginning of the expanded value of PARAMETER, then the result of
     the expansion is the expanded value of PARAMETER with the shortest
     matching pattern (the '#' case) or the longest matching pattern
     (the '##' case) deleted.  If PARAMETER is '@' or '*', the pattern
     removal operation is applied to each positional parameter in turn,
     and the expansion is the resultant list.  If PARAMETER is an array
     variable subscripted with '@' or '*', the pattern removal operation
     is applied to each member of the array in turn, and the expansion
     is the resultant list.

'${PARAMETER%WORD}'
'${PARAMETER%%WORD}'
     The WORD is expanded to produce a pattern just as in filename
     expansion.  If the pattern matches a trailing portion of the
     expanded value of PARAMETER, then the result of the expansion is
     the value of PARAMETER with the shortest matching pattern (the '%'
     case) or the longest matching pattern (the '%%' case) deleted.  If
     PARAMETER is '@' or '*', the pattern removal operation is applied
     to each positional parameter in turn, and the expansion is the
     resultant list.  If PARAMETER is an array variable subscripted with
     '@' or '*', the pattern removal operation is applied to each member
     of the array in turn, and the expansion is the resultant list.

'${PARAMETER/PATTERN/STRING}'

     The PATTERN is expanded to produce a pattern just as in filename
     expansion.  PARAMETER is expanded and the longest match of PATTERN
     against its value is replaced with STRING.  If PATTERN begins with
     '/', all matches of PATTERN are replaced with STRING.  Normally
     only the first match is replaced.  If PATTERN begins with '#', it
     must match at the beginning of the expanded value of PARAMETER.  If
     PATTERN begins with '%', it must match at the end of the expanded
     value of PARAMETER.  If STRING is null, matches of PATTERN are
     deleted and the '/' following PATTERN may be omitted.  If PARAMETER
     is '@' or '*', the substitution operation is applied to each
     positional parameter in turn, and the expansion is the resultant
     list.  If PARAMETER is an array variable subscripted with '@' or
     '*', the substitution operation is applied to each member of the
     array in turn, and the expansion is the resultant list.

'${PARAMETER^PATTERN}'
'${PARAMETER^^PATTERN}'
'${PARAMETER,PATTERN}'
'${PARAMETER,,PATTERN}'
     This expansion modifies the case of alphabetic characters in
     PARAMETER.  The PATTERN is expanded to produce a pattern just as in
     filename expansion.  The '^' operator converts lowercase letters
     matching PATTERN to uppercase; the ',' operator converts matching
     uppercase letters to lowercase.  The '^^' and ',,' expansions
     convert each matched character in the expanded value; the '^' and
     ',' expansions match and convert only the first character in the
     expanded value.  If PATTERN is omitted, it is treated like a '?',
     which matches every character.  If PARAMETER is '@' or '*', the
     case modification operation is applied to each positional parameter
     in turn, and the expansion is the resultant list.  If PARAMETER is
     an array variable subscripted with '@' or '*', the case
     modification operation is applied to each member of the array in
     turn, and the expansion is the resultant list.

3.5.4 Command Substitution
--------------------------

Command substitution allows the output of a command to replace the
command itself.  Command substitution occurs when a command is enclosed
as follows:
     $(COMMAND)
or
     `COMMAND`

Bash performs the expansion by executing COMMAND and replacing the
command substitution with the standard output of the command, with any
trailing newlines deleted.  Embedded newlines are not deleted, but they
may be removed during word splitting.  The command substitution '$(cat
FILE)' can be replaced by the equivalent but faster '$(< FILE)'.

   When the old-style backquote form of substitution is used, backslash
retains its literal meaning except when followed by '$', '`', or '\'.
The first backquote not preceded by a backslash terminates the command
substitution.  When using the '$(COMMAND)' form, all characters between
the parentheses make up the command; none are treated specially.

   Command substitutions may be nested.  To nest when using the
backquoted form, escape the inner backquotes with backslashes.

   If the substitution appears within double quotes, word splitting and
filename expansion are not performed on the results.

3.5.5 Arithmetic Expansion
--------------------------

Arithmetic expansion allows the evaluation of an arithmetic expression
and the substitution of the result.  The format for arithmetic expansion
is:

     $(( EXPRESSION ))

   The expression is treated as if it were within double quotes, but a
double quote inside the parentheses is not treated specially.  All
tokens in the expression undergo parameter expansion, command
substitution, and quote removal.  Arithmetic expansions may be nested.

   The evaluation is performed according to the rules listed below
(*note Shell Arithmetic::).  If the expression is invalid, Bash prints a
message indicating failure to the standard error and no substitution
occurs.

3.5.6 Process Substitution
--------------------------

Process substitution is supported on systems that support named pipes
(FIFOs) or the '/dev/fd' method of naming open files.  It takes the form
of
     <(LIST)
or
     >(LIST)
The process LIST is run with its input or output connected to a FIFO or
some file in '/dev/fd'.  The name of this file is passed as an argument
to the current command as the result of the expansion.  If the '>(LIST)'
form is used, writing to the file will provide input for LIST.  If the
'<(LIST)' form is used, the file passed as an argument should be read to
obtain the output of LIST.  Note that no space may appear between the
'<' or '>' and the left parenthesis, otherwise the construct would be
interpreted as a redirection.

   When available, process substitution is performed simultaneously with
parameter and variable expansion, command substitution, and arithmetic
expansion.

3.5.7 Word Splitting
--------------------

The shell scans the results of parameter expansion, command
substitution, and arithmetic expansion that did not occur within double
quotes for word splitting.

   The shell treats each character of '$IFS' as a delimiter, and splits
the results of the other expansions into words on these characters.  If
'IFS' is unset, or its value is exactly '<space><tab><newline>', the
default, then sequences of ' <space>', '<tab>', and '<newline>' at the
beginning and end of the results of the previous expansions are ignored,
and any sequence of 'IFS' characters not at the beginning or end serves
to delimit words.  If 'IFS' has a value other than the default, then
sequences of the whitespace characters 'space' and 'tab' are ignored at
the beginning and end of the word, as long as the whitespace character
is in the value of 'IFS' (an 'IFS' whitespace character).  Any character
in 'IFS' that is not 'IFS' whitespace, along with any adjacent 'IFS'
whitespace characters, delimits a field.  A sequence of 'IFS' whitespace
characters is also treated as a delimiter.  If the value of 'IFS' is
null, no word splitting occurs.

   Explicit null arguments ('""' or '''') are retained.  Unquoted
implicit null arguments, resulting from the expansion of parameters that
have no values, are removed.  If a parameter with no value is expanded
within double quotes, a null argument results and is retained.

   Note that if no expansion occurs, no splitting is performed.

3.5.8 Filename Expansion
------------------------

After word splitting, unless the '-f' option has been set (*note The Set
Builtin::), Bash scans each word for the characters '*', '?', and '['.
If one of these characters appears, then the word is regarded as a
PATTERN, and replaced with an alphabetically sorted list of file names
matching the pattern.  If no matching file names are found, and the
shell option 'nullglob' is disabled, the word is left unchanged.  If the
'nullglob' option is set, and no matches are found, the word is removed.
If the 'failglob' shell option is set, and no matches are found, an
error message is printed and the command is not executed.  If the shell
option 'nocaseglob' is enabled, the match is performed without regard to
the case of alphabetic characters.

   When a pattern is used for filename expansion, the character '.' at
the start of a filename or immediately following a slash must be matched
explicitly, unless the shell option 'dotglob' is set.  When matching a
file name, the slash character must always be matched explicitly.  In
other cases, the '.' character is not treated specially.

   See the description of 'shopt' in *note The Shopt Builtin::, for a
description of the 'nocaseglob', 'nullglob', 'failglob', and 'dotglob'
options.

   The 'GLOBIGNORE' shell variable may be used to restrict the set of
filenames matching a pattern.  If 'GLOBIGNORE' is set, each matching
filename that also matches one of the patterns in 'GLOBIGNORE' is
removed from the list of matches.  The filenames '.' and '..' are always
ignored when 'GLOBIGNORE' is set and not null.  However, setting
'GLOBIGNORE' to a non-null value has the effect of enabling the
'dotglob' shell option, so all other filenames beginning with a '.' will
match.  To get the old behavior of ignoring filenames beginning with a
'.', make '.*' one of the patterns in 'GLOBIGNORE'.  The 'dotglob'
option is disabled when 'GLOBIGNORE' is unset.

3.5.8.1 Pattern Matching
........................

Any character that appears in a pattern, other than the special pattern
characters described below, matches itself.  The NUL character may not
occur in a pattern.  A backslash escapes the following character; the
escaping backslash is discarded when matching.  The special pattern
characters must be quoted if they are to be matched literally.

   The special pattern characters have the following meanings:
'*'
     Matches any string, including the null string.  When the 'globstar'
     shell option is enabled, and '*' is used in a filename expansion
     context, two adjacent '*'s used as a single pattern will match all
     files and zero or more directories and subdirectories.  If followed
     by a '/', two adjacent '*'s will match only directories and
     subdirectories.
'?'
     Matches any single character.
'[...]'
     Matches any one of the enclosed characters.  A pair of characters
     separated by a hyphen denotes a RANGE EXPRESSION; any character
     that sorts between those two characters, inclusive, using the
     current locale's collating sequence and character set, is matched.
     If the first character following the '[' is a '!' or a '^' then any
     character not enclosed is matched.  A '-' may be matched by
     including it as the first or last character in the set.  A ']' may
     be matched by including it as the first character in the set.  The
     sorting order of characters in range expressions is determined by
     the current locale and the value of the 'LC_COLLATE' shell
     variable, if set.

     For example, in the default C locale, '[a-dx-z]' is equivalent to
     '[abcdxyz]'.  Many locales sort characters in dictionary order, and
     in these locales '[a-dx-z]' is typically not equivalent to
     '[abcdxyz]'; it might be equivalent to '[aBbCcDdxXyYz]', for
     example.  To obtain the traditional interpretation of ranges in
     bracket expressions, you can force the use of the C locale by
     setting the 'LC_COLLATE' or 'LC_ALL' environment variable to the
     value 'C'.

     Within '[' and ']', CHARACTER CLASSES can be specified using the
     syntax '[:'CLASS':]', where CLASS is one of the following classes
     defined in the POSIX standard:
          alnum   alpha   ascii   blank   cntrl   digit   graph   lower
          print   punct   space   upper   word    xdigit
     A character class matches any character belonging to that class.
     The 'word' character class matches letters, digits, and the
     character '_'.

     Within '[' and ']', an EQUIVALENCE CLASS can be specified using the
     syntax '[='C'=]', which matches all characters with the same
     collation weight (as defined by the current locale) as the
     character C.

     Within '[' and ']', the syntax '[.'SYMBOL'.]' matches the collating
     symbol SYMBOL.

   If the 'extglob' shell option is enabled using the 'shopt' builtin,
several extended pattern matching operators are recognized.  In the
following description, a PATTERN-LIST is a list of one or more patterns
separated by a '|'.  Composite patterns may be formed using one or more
of the following sub-patterns:

'?(PATTERN-LIST)'
     Matches zero or one occurrence of the given patterns.

'*(PATTERN-LIST)'
     Matches zero or more occurrences of the given patterns.

'+(PATTERN-LIST)'
     Matches one or more occurrences of the given patterns.

'@(PATTERN-LIST)'
     Matches one of the given patterns.

'!(PATTERN-LIST)'
     Matches anything except one of the given patterns.

3.5.9 Quote Removal
-------------------

After the preceding expansions, all unquoted occurrences of the
characters '\', ''', and '"' that did not result from one of the above
expansions are removed.

3.6 Redirections
================

Before a command is executed, its input and output may be REDIRECTED
using a special notation interpreted by the shell.  Redirection may also
be used to open and close files for the current shell execution
environment.  The following redirection operators may precede or appear
anywhere within a simple command or may follow a command.  Redirections
are processed in the order they appear, from left to right.

   Each redirection that may be preceded by a file descriptor number may
instead be preceded by a word of the form {VARNAME}.  In this case, for
each redirection operator except >&- and <&-, the shell will allocate a
file descriptor greater than 10 and assign it to {VARNAME}.  If >&- or
<&- is preceded by {VARNAME}, the value of VARNAME defines the file
descriptor to close.

   In the following descriptions, if the file descriptor number is
omitted, and the first character of the redirection operator is '<', the
redirection refers to the standard input (file descriptor 0).  If the
first character of the redirection operator is '>', the redirection
refers to the standard output (file descriptor 1).

   The word following the redirection operator in the following
descriptions, unless otherwise noted, is subjected to brace expansion,
tilde expansion, parameter expansion, command substitution, arithmetic
expansion, quote removal, filename expansion, and word splitting.  If it
expands to more than one word, Bash reports an error.

   Note that the order of redirections is significant.  For example, the
command
     ls > DIRLIST 2>&1
directs both standard output (file descriptor 1) and standard error
(file descriptor 2) to the file DIRLIST, while the command
     ls 2>&1 > DIRLIST
directs only the standard output to file DIRLIST, because the standard
error was made a copy of the standard output before the standard output
was redirected to DIRLIST.

   Bash handles several filenames specially when they are used in
redirections, as described in the following table:

'/dev/fd/FD'
     If FD is a valid integer, file descriptor FD is duplicated.

'/dev/stdin'
     File descriptor 0 is duplicated.

'/dev/stdout'
     File descriptor 1 is duplicated.

'/dev/stderr'
     File descriptor 2 is duplicated.

'/dev/tcp/HOST/PORT'
     If HOST is a valid hostname or Internet address, and PORT is an
     integer port number or service name, Bash attempts to open a TCP
     connection to the corresponding socket.

'/dev/udp/HOST/PORT'
     If HOST is a valid hostname or Internet address, and PORT is an
     integer port number or service name, Bash attempts to open a UDP
     connection to the corresponding socket.

   A failure to open or create a file causes the redirection to fail.

   Redirections using file descriptors greater than 9 should be used
with care, as they may conflict with file descriptors the shell uses
internally.

3.6.1 Redirecting Input
-----------------------

Redirection of input causes the file whose name results from the
expansion of WORD to be opened for reading on file descriptor 'n', or
the standard input (file descriptor 0) if 'n' is not specified.

   The general format for redirecting input is:
     [N]<WORD

3.6.2 Redirecting Output
------------------------

Redirection of output causes the file whose name results from the
expansion of WORD to be opened for writing on file descriptor N, or the
standard output (file descriptor 1) if N is not specified.  If the file
does not exist it is created; if it does exist it is truncated to zero
size.

   The general format for redirecting output is:
     [N]>[|]WORD

   If the redirection operator is '>', and the 'noclobber' option to the
'set' builtin has been enabled, the redirection will fail if the file
whose name results from the expansion of WORD exists and is a regular
file.  If the redirection operator is '>|', or the redirection operator
is '>' and the 'noclobber' option is not enabled, the redirection is
attempted even if the file named by WORD exists.

3.6.3 Appending Redirected Output
---------------------------------

Redirection of output in this fashion causes the file whose name results
from the expansion of WORD to be opened for appending on file descriptor
N, or the standard output (file descriptor 1) if N is not specified.  If
the file does not exist it is created.

   The general format for appending output is:
     [N]>>WORD

3.6.4 Redirecting Standard Output and Standard Error
----------------------------------------------------

This construct allows both the standard output (file descriptor 1) and
the standard error output (file descriptor 2) to be redirected to the
file whose name is the expansion of WORD.

   There are two formats for redirecting standard output and standard
error:
     &>WORD
and
     >&WORD
Of the two forms, the first is preferred.  This is semantically
equivalent to
     >WORD 2>&1

3.6.5 Appending Standard Output and Standard Error
--------------------------------------------------

This construct allows both the standard output (file descriptor 1) and
the standard error output (file descriptor 2) to be appended to the file
whose name is the expansion of WORD.

   The format for appending standard output and standard error is:
     &>>WORD
This is semantically equivalent to
     >>WORD 2>&1

3.6.6 Here Documents
--------------------

This type of redirection instructs the shell to read input from the
current source until a line containing only WORD (with no trailing
blanks) is seen.  All of the lines read up to that point are then used
as the standard input for a command.

   The format of here-documents is:
     <<[-]WORD
             HERE-DOCUMENT
     DELIMITER

   No parameter expansion, command substitution, arithmetic expansion,
or filename expansion is performed on WORD.  If any characters in WORD
are quoted, the DELIMITER is the result of quote removal on WORD, and
the lines in the here-document are not expanded.  If WORD is unquoted,
all lines of the here-document are subjected to parameter expansion,
command substitution, and arithmetic expansion.  In the latter case, the
character sequence '\newline' is ignored, and '\' must be used to quote
the characters '\', '$', and '`'.

   If the redirection operator is '<<-', then all leading tab characters
are stripped from input lines and the line containing DELIMITER.  This
allows here-documents within shell scripts to be indented in a natural
fashion.

3.6.7 Here Strings
------------------

A variant of here documents, the format is:
     <<< WORD

   The WORD is expanded and supplied to the command on its standard
input.

3.6.8 Duplicating File Descriptors
----------------------------------

The redirection operator
     [N]<&WORD
is used to duplicate input file descriptors.  If WORD expands to one or
more digits, the file descriptor denoted by N is made to be a copy of
that file descriptor.  If the digits in WORD do not specify a file
descriptor open for input, a redirection error occurs.  If WORD
evaluates to '-', file descriptor N is closed.  If N is not specified,
the standard input (file descriptor 0) is used.

   The operator
     [N]>&WORD
is used similarly to duplicate output file descriptors.  If N is not
specified, the standard output (file descriptor 1) is used.  If the
digits in WORD do not specify a file descriptor open for output, a
redirection error occurs.  As a special case, if N is omitted, and WORD
does not expand to one or more digits, the standard output and standard
error are redirected as described previously.

3.6.9 Moving File Descriptors
-----------------------------

The redirection operator
     [N]<&DIGIT-
moves the file descriptor DIGIT to file descriptor N, or the standard
input (file descriptor 0) if N is not specified.  DIGIT is closed after
being duplicated to N.

   Similarly, the redirection operator
     [N]>&DIGIT-
moves the file descriptor DIGIT to file descriptor N, or the standard
output (file descriptor 1) if N is not specified.

3.6.10 Opening File Descriptors for Reading and Writing
-------------------------------------------------------

The redirection operator
     [N]<>WORD
causes the file whose name is the expansion of WORD to be opened for
both reading and writing on file descriptor N, or on file descriptor 0
if N is not specified.  If the file does not exist, it is created.

3.7 Executing Commands
======================

3.7.1 Simple Command Expansion
------------------------------

When a simple command is executed, the shell performs the following
expansions, assignments, and redirections, from left to right.

  1. The words that the parser has marked as variable assignments (those
     preceding the command name) and redirections are saved for later
     processing.

  2. The words that are not variable assignments or redirections are
     expanded (*note Shell Expansions::).  If any words remain after
     expansion, the first word is taken to be the name of the command
     and the remaining words are the arguments.

  3. Redirections are performed as described above (*note
     Redirections::).

  4. The text after the '=' in each variable assignment undergoes tilde
     expansion, parameter expansion, command substitution, arithmetic
     expansion, and quote removal before being assigned to the variable.

   If no command name results, the variable assignments affect the
current shell environment.  Otherwise, the variables are added to the
environment of the executed command and do not affect the current shell
environment.  If any of the assignments attempts to assign a value to a
readonly variable, an error occurs, and the command exits with a
non-zero status.

   If no command name results, redirections are performed, but do not
affect the current shell environment.  A redirection error causes the
command to exit with a non-zero status.

   If there is a command name left after expansion, execution proceeds
as described below.  Otherwise, the command exits.  If one of the
expansions contained a command substitution, the exit status of the
command is the exit status of the last command substitution performed.
If there were no command substitutions, the command exits with a status
of zero.

3.7.2 Command Search and Execution
----------------------------------

After a command has been split into words, if it results in a simple
command and an optional list of arguments, the following actions are
taken.

  1. If the command name contains no slashes, the shell attempts to
     locate it.  If there exists a shell function by that name, that
     function is invoked as described in *note Shell Functions::.

  2. If the name does not match a function, the shell searches for it in
     the list of shell builtins.  If a match is found, that builtin is
     invoked.

  3. If the name is neither a shell function nor a builtin, and contains
     no slashes, Bash searches each element of '$PATH' for a directory
     containing an executable file by that name.  Bash uses a hash table
     to remember the full pathnames of executable files to avoid
     multiple 'PATH' searches (see the description of 'hash' in *note
     Bourne Shell Builtins::).  A full search of the directories in
     '$PATH' is performed only if the command is not found in the hash
     table.  If the search is unsuccessful, the shell searches for a
     defined shell function named 'command_not_found_handle'.  If that
     function exists, it is invoked with the original command and the
     original command's arguments as its arguments, and the function's
     exit status becomes the exit status of the shell.  If that function
     is not defined, the shell prints an error message and returns an
     exit status of 127.

  4. If the search is successful, or if the command name contains one or
     more slashes, the shell executes the named program in a separate
     execution environment.  Argument 0 is set to the name given, and
     the remaining arguments to the command are set to the arguments
     supplied, if any.

  5. If this execution fails because the file is not in executable
     format, and the file is not a directory, it is assumed to be a
     SHELL SCRIPT and the shell executes it as described in *note Shell
     Scripts::.

  6. If the command was not begun asynchronously, the shell waits for
     the command to complete and collects its exit status.

3.7.3 Command Execution Environment
-----------------------------------

The shell has an EXECUTION ENVIRONMENT, which consists of the following:

   * open files inherited by the shell at invocation, as modified by
     redirections supplied to the 'exec' builtin

   * the current working directory as set by 'cd', 'pushd', or 'popd',
     or inherited by the shell at invocation

   * the file creation mode mask as set by 'umask' or inherited from the
     shell's parent

   * current traps set by 'trap'

   * shell parameters that are set by variable assignment or with 'set'
     or inherited from the shell's parent in the environment

   * shell functions defined during execution or inherited from the
     shell's parent in the environment

   * options enabled at invocation (either by default or with
     command-line arguments) or by 'set'

   * options enabled by 'shopt' (*note The Shopt Builtin::)

   * shell aliases defined with 'alias' (*note Aliases::)

   * various process IDs, including those of background jobs (*note
     Lists::), the value of '$$', and the value of '$PPID'

   When a simple command other than a builtin or shell function is to be
executed, it is invoked in a separate execution environment that
consists of the following.  Unless otherwise noted, the values are
inherited from the shell.

   * the shell's open files, plus any modifications and additions
     specified by redirections to the command

   * the current working directory

   * the file creation mode mask

   * shell variables and functions marked for export, along with
     variables exported for the command, passed in the environment
     (*note Environment::)

   * traps caught by the shell are reset to the values inherited from
     the shell's parent, and traps ignored by the shell are ignored

   A command invoked in this separate environment cannot affect the
shell's execution environment.

   Command substitution, commands grouped with parentheses, and
asynchronous commands are invoked in a subshell environment that is a
duplicate of the shell environment, except that traps caught by the
shell are reset to the values that the shell inherited from its parent
at invocation.  Builtin commands that are invoked as part of a pipeline
are also executed in a subshell environment.  Changes made to the
subshell environment cannot affect the shell's execution environment.

   Subshells spawned to execute command substitutions inherit the value
of the '-e' option from the parent shell.  When not in POSIX mode, Bash
clears the '-e' option in such subshells.

   If a command is followed by a '&' and job control is not active, the
default standard input for the command is the empty file '/dev/null'.
Otherwise, the invoked command inherits the file descriptors of the
calling shell as modified by redirections.

3.7.4 Environment
-----------------

When a program is invoked it is given an array of strings called the
ENVIRONMENT.  This is a list of name-value pairs, of the form
'name=value'.

   Bash provides several ways to manipulate the environment.  On
invocation, the shell scans its own environment and creates a parameter
for each name found, automatically marking it for EXPORT to child
processes.  Executed commands inherit the environment.  The 'export' and
'declare -x' commands allow parameters and functions to be added to and
deleted from the environment.  If the value of a parameter in the
environment is modified, the new value becomes part of the environment,
replacing the old.  The environment inherited by any executed command
consists of the shell's initial environment, whose values may be
modified in the shell, less any pairs removed by the 'unset' and 'export
-n' commands, plus any additions via the 'export' and 'declare -x'
commands.

   The environment for any simple command or function may be augmented
temporarily by prefixing it with parameter assignments, as described in
*note Shell Parameters::.  These assignment statements affect only the
environment seen by that command.

   If the '-k' option is set (*note The Set Builtin::), then all
parameter assignments are placed in the environment for a command, not
just those that precede the command name.

   When Bash invokes an external command, the variable '$_' is set to
the full path name of the command and passed to that command in its
environment.

3.7.5 Exit Status
-----------------

The exit status of an executed command is the value returned by the
WAITPID system call or equivalent function.  Exit statuses fall between
0 and 255, though, as explained below, the shell may use values above
125 specially.  Exit statuses from shell builtins and compound commands
are also limited to this range.  Under certain circumstances, the shell
will use special values to indicate specific failure modes.

   For the shell's purposes, a command which exits with a zero exit
status has succeeded.  A non-zero exit status indicates failure.  This
seemingly counter-intuitive scheme is used so there is one well-defined
way to indicate success and a variety of ways to indicate various
failure modes.  When a command terminates on a fatal signal whose number
is N, Bash uses the value 128+N as the exit status.

   If a command is not found, the child process created to execute it
returns a status of 127.  If a command is found but is not executable,
the return status is 126.

   If a command fails because of an error during expansion or
redirection, the exit status is greater than zero.

   The exit status is used by the Bash conditional commands (*note
Conditional Constructs::) and some of the list constructs (*note
Lists::).

   All of the Bash builtins return an exit status of zero if they
succeed and a non-zero status on failure, so they may be used by the
conditional and list constructs.  All builtins return an exit status of
2 to indicate incorrect usage.

3.7.6 Signals
-------------

When Bash is interactive, in the absence of any traps, it ignores
'SIGTERM' (so that 'kill 0' does not kill an interactive shell), and
'SIGINT' is caught and handled (so that the 'wait' builtin is
interruptible).  When Bash receives a 'SIGINT', it breaks out of any
executing loops.  In all cases, Bash ignores 'SIGQUIT'.  If job control
is in effect (*note Job Control::), Bash ignores 'SIGTTIN', 'SIGTTOU',
and 'SIGTSTP'.

   Non-builtin commands started by Bash have signal handlers set to the
values inherited by the shell from its parent.  When job control is not
in effect, asynchronous commands ignore 'SIGINT' and 'SIGQUIT' in
addition to these inherited handlers.  Commands run as a result of
command substitution ignore the keyboard-generated job control signals
'SIGTTIN', 'SIGTTOU', and 'SIGTSTP'.

   The shell exits by default upon receipt of a 'SIGHUP'.  Before
exiting, an interactive shell resends the 'SIGHUP' to all jobs, running
or stopped.  Stopped jobs are sent 'SIGCONT' to ensure that they receive
the 'SIGHUP'.  To prevent the shell from sending the 'SIGHUP' signal to
a particular job, it should be removed from the jobs table with the
'disown' builtin (*note Job Control Builtins::) or marked to not receive
'SIGHUP' using 'disown -h'.

   If the 'huponexit' shell option has been set with 'shopt' (*note The
Shopt Builtin::), Bash sends a 'SIGHUP' to all jobs when an interactive
login shell exits.

   If Bash is waiting for a command to complete and receives a signal
for which a trap has been set, the trap will not be executed until the
command completes.  When Bash is waiting for an asynchronous command via
the 'wait' builtin, the reception of a signal for which a trap has been
set will cause the 'wait' builtin to return immediately with an exit
status greater than 128, immediately after which the trap is executed.

3.8 Shell Scripts
=================

A shell script is a text file containing shell commands.  When such a
file is used as the first non-option argument when invoking Bash, and
neither the '-c' nor '-s' option is supplied (*note Invoking Bash::),
Bash reads and executes commands from the file, then exits.  This mode
of operation creates a non-interactive shell.  The shell first searches
for the file in the current directory, and looks in the directories in
'$PATH' if not found there.

   When Bash runs a shell script, it sets the special parameter '0' to
the name of the file, rather than the name of the shell, and the
positional parameters are set to the remaining arguments, if any are
given.  If no additional arguments are supplied, the positional
parameters are unset.

   A shell script may be made executable by using the 'chmod' command to
turn on the execute bit.  When Bash finds such a file while searching
the '$PATH' for a command, it spawns a subshell to execute it.  In other
words, executing
     filename ARGUMENTS
is equivalent to executing
     bash filename ARGUMENTS

if 'filename' is an executable shell script.  This subshell
reinitializes itself, so that the effect is as if a new shell had been
invoked to interpret the script, with the exception that the locations
of commands remembered by the parent (see the description of 'hash' in
*note Bourne Shell Builtins::) are retained by the child.

   Most versions of Unix make this a part of the operating system's
command execution mechanism.  If the first line of a script begins with
the two characters '#!', the remainder of the line specifies an
interpreter for the program.  Thus, you can specify Bash, 'awk', Perl,
or some other interpreter and write the rest of the script file in that
language.

   The arguments to the interpreter consist of a single optional
argument following the interpreter name on the first line of the script
file, followed by the name of the script file, followed by the rest of
the arguments.  Bash will perform this action on operating systems that
do not handle it themselves.  Note that some older versions of Unix
limit the interpreter name and argument to a maximum of 32 characters.

   Bash scripts often begin with '#! /bin/bash' (assuming that Bash has
been installed in '/bin'), since this ensures that Bash will be used to
interpret the script, even if it is executed under another shell.